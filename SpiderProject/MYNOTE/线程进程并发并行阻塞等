
进程和线程
进程:
1,一段程序的执行过程;
2,进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

解释:
1,进程是一个实体.每一个进程都有它自己的地址空间,一般包括文本区域/数据区域/堆栈;
文本区域:存储处理器执行的代码
数据区域:存储变量和进程执行期间使用的动态分配内存;
堆栈区域:存储着活动过程调用的指令和本地变量;
2,进程是一个'执行中的程序'.程序是一个没有生命的实体,只有处理器赋予程序生命时,它才能成为活动的实体,我们称其为进程.
进程状态:
1,就绪:获取了除cpu外的所有资源,只要处理器分配资源就可以马上执行.
2,运行:获得了处理器的分配资源,程序开始执行.
3,阻塞:当程序条件不够时候,需要等待条件满足时候才能执行,(水缸里的水等满了,人为倒掉和自动倒掉区分)(简单说:排队意味着阻塞,交叉执行意味着不阻塞)

程序:
指令和数据的有序集合,其本身没有任何的含义,是一个静态的概念.而进程则是在处理机上的一次执行程序,它是一个动态的概念.进程是包含程序的,进程的执行离不开程序,进程中的文本区域就是代码区,也就是程序.

线程:
通常在一个进程中可以包含若干个线程,当然一个进程中至少有一个线程,,不然没有存在的意义.线程可拥有进程所拥有的资源,在引入线程的操作系统中,通常都是把进程作为分配资源的基本单位,而把线程作为独立运行和独立调度的基本单位,由于线程比进程更小,基本上不拥有系统资源,故对它的调度所付出的开销就会小得多,能更高效的提高系统多个程序间并发执行的程度.

多线程

在一个程序中,这些独立运行的程序片段叫做"线程(thread)",利用它编程叫做多线程处理.多线程是为了同步完成多项任务,不是为了提高运行效率,而是为了提高资源的使用效率,来提高系统的效率.线程是在同一时间需要完成多项任务的时候实现的.

线程锁:
由于线程在进程中运行,都拥有全部资源,没有确切分配地址,其中A线程中的资源有可能被B线程使用,这里就引入了线程锁概念.
目的:锁住资源,防止被别的线程使用该资源(局部变量),造成bug;
使用方式:
1,定义线程锁:
my_lock = threading.Lock()
2,启用线程锁:
if my_lock.acquire():
3,关闭线程锁:
my_lock.release()

进程与线程的区别:
1,不同的操作系统资源管理方式,进程有独立地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间,
2,进程切换时,耗费资源较大,效率要差一些,但对于一些要求同时进行并且又要共享某些变量的并发操作,只能用线程,不能用进程.


1,简而言之,一个程序至少有一个进程,一个进程至少有一个线程;
2,线程划分尺度小于进程,使得多线程程序的并发性高.
3,进程在执行过程中拥有独立的内存单元,而多个线程共享内存,从而极大的提高了程序的运行效率;
4,每个独立的进程有一个程序运行的入口\顺序执行序列和程序出口.但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制.

5,逻辑角度,多线程在一个应用程序中,有多个执行部分可以同时执行,但操作系统并没有将多个线程看做多个独立应用,来实现进程的调度和管理以及分配.

优缺点:
线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。
**************************************************************************
协程:
其实就是一个线程，在执行过程中，在程序内部可中断，然后转而执行别的程序，在适当的时候再返回来接着执行;

总结一下：

最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

*********************************************************************
生成器:
使用了 yield 的函数被称为生成器（generator）。生成器函数返回的结果就是一个迭代器，只能用于迭代操作。既然是迭代器了，就有__next__()的属性了。

那生成器是怎么工作的呢：在调用生成器运行的过程中，当在第一次运行的时候，在遇到yield时函数会暂停并保持当前所有的运行信息，返回一个yield的值，当再次__next__()的时候，才会在当前代码位置进行运行。

迭代器:
访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。

普通方式创建迭代对象:
iter(collection) -> iterator

iter(callable,sentinel) -> iterator



1,同步异步:

	针对结果


2,阻塞非阻塞:
	针对运行状态:就绪,运行,阻塞

3,并发并行:


